@startuml

start

:寻找对比目标;
note right
  React为了提高对比效率，做出以下假设：
  ====
  假设节点不会出现层次的移动（对比时，直接找到旧树中对应位置的节点进行对比）
  ====
  不同的节点类型会生成不同的结构 
  * 相同的节点类型：节点本身类型相同，如果是由React元素生成，type值还必须一致
  * 其他的，都属于不相同的节点类型 
  ====
  多个兄弟通过唯一标识（key）来确定对比的新节点 
  * **key值的作用 **： 用于通过旧节点，寻找对应的新节点，如果某个旧节点有key值，则其更新时，会**寻找相同层级中**的相同key值的节点，进行对比
  * key值应该在一个范围内唯一（兄弟节点中），并且应该保持稳定

end note
if(是否找到对比目标) then(是)
    if(判断节点类型是否一致) then(是)
        :判断节点类型;
        if(空节点)
            :什么都不做;
        elseif(DOM节点)
            :直接重用之前的真实DOM对象;
            :将其属性的变化记录下来，以待将来统一完成更新（现在不会真正的变化）;
            :遍历该新的React元素的子元素，**递归对比更新**;
        elseif(文本节点)
            :直接重用之前的真实DOM对象 ;
            :将新的文本变化记录下来，将来统一完成更新;
        elseif(函数组件)
            :重新调用函数，得到一个节点对象，进入**递归对比更新**;
        elseif(类组件)
            :重用之前的实例 ;
            :调用生命周期方法static getDerivedStateFromProps;
            :调用生命周期方法shouldComponentUpdate;
                if(shouldComponentUpdate返回值) then(false)
                    stop
                else(true)
                    :运行render，得到新的节点对象，进入**递归对比更新**;
                    :将该对象的getSnapshotBeforeUpdate加入队列;
                    :将该对象的componentDidUpdate加入队列;
                endif
        elseif(组件节点)
            :遍历数组进行**递归对比更新**;
        endif
    else(否)
        :创建新节点,进入新节点的渲染流程;
        :卸载旧节点;
        if(节点类型) then(类组件节点)
            :直接放弃该节点;
            :调用该节点的componentWillUnMount函数;
            :递归卸载子节点;
        else(其他节点)
            :直接放弃该节点，如果节点有子节点，递归卸载节点;
        endif
    endif
else(否)
    :创建新加入的节点;
    :卸载多余的旧节点;
endif

stop

@enduml
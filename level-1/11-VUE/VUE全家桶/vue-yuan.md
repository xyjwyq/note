[TOC]

## 1.颠覆式开发方式

### 问题

1. 为什么要使用 Vue?

   - 降低项目的复杂度
   - 就业需要

2. Vue 难不难？

   不难

3. 相比于React, Vue有什么优势？

   前端三大框架：Angular、React、Vue

   Vue的优势：

   - 学习成本低
   - Vue已经自动对执行效率进行了优化，初学者完全不用考虑效率问题

   React：更接近底层，更灵活，但是学习成本高，要较好的使用，需要掌握的很深入，即掌握至源码级别，否则，使用其书写项目的效果反而会大打折扣

4. Vue的特点

   - 渐进式：Vue的侵入性很少，可以与很多其他前端技术联用（Vue只控制指定的容器，一个Vue实例控制一个容器）
   - 组件化
   - 响应式：数据响应式，Vue会监控数据的变化，当数据发生变化时，自动重新渲染页面

### 核心功能

关于创建Vue工程

- 直接页面引用vue.js
- 使用脚手架(vue-cli搭建工程，需要的前置知识(nodejs、webpack、saaa、less、css-module、命令行开发)

1. Vue实例：通过`new Vue()`得到的实例

   1）当创建Vue实例时，Vue会将下面的配置成员提升到Vue实例中

   - data配置：目的是为了实现响应式
   - methods配置：为了在模板中方便使用
   - computed配置：

   2) 由于有提升的存在，Vue会将自身的成员加上 `$` 或 `_`，目的是为了防止命名冲突问题，其中`$`是指用户可以使用的属性，`_`是指系统内部使用的属性

2. 模板

   - 插值：在模板(template)的元素内使用`{{ js表达式 }}`，模板的环境
   - 指令：通常作为元素的属性存在，名称上以`v-`开头
     - v-for：用于循环生成元素
     - v-on：用于注册事件，简写`@`
     - v-if：用于判断该元素是否生成
     - v-show：用于判断该元素是否显示，可以和``v-elseif/v-else`联用
     - v-bind：用于绑定属性，简写`:`
     - v-model：语法糖，用于实现双向数据绑定，实际上，是自动绑定了value属性值和后侧了input事件
     - v-html：用户解析html语句
     - v-slot：插槽，简写`#`
   - 模板的配置
     - 页面中直接书写
     - 在template配置中书写（常用）
     - 在render中手动用函数实现，render函数的参数是一个创建虚拟DOM对象的方法

3. 配置对象

   - `template`：字符串，配置模板
   - `el`：配置控制的元素，css选择器
   - `data`：管理的数据，该数据是响应式的,
   - `methods`：配置方法，方法中的`this`指向Vue实例，不能使用箭头函数，会干扰`this`的绑定
   - `computed`：计算属性，该配置会提升至Vue实例中，因此，在模板中可以直接当做属性使用，使用时，实际上调用的是对应的方法；通常，计算属性用于通过data或者其他计算属性的得到的数据；

4. computed与methods的区别

   1) Vue会检查计算属性的依赖，当依赖没有发生变化时，Vue会直接使用之前缓存的结果，而不会重新计算

   2) 计算属性的读取函数，不可以有参数

   3) 计算属性可以配置get、set函数，分别用于读取和设置时

## 2. 组件化开发体验

1. 关于模块化

   **面对大型项目，传统开开发的问题**

   - 如何管理错综复杂的代码
   - 如何处理全局对象污染问题
   - 如何管理复杂的依赖关系

   **实现模块化的方式**：CommonJs、AMD、CMD、ES6

   **ES6模块化**

   - 模块汇中的所有变量，全部是局部的，只能在模块内部使用
   - 模块导出：`export default`导出的数据
   - 模块导入(在所有代码之前导入)：`import variable from module-path`

2. 什么是组件？

   组件是页面中的一个可复用的功能单元

3. Vue中的组件

   1) 组件的创建：组件对于开发者，是一个普通的配置对象，该配置对象几乎和之前学习的Vue配置一致

   2) 组件注册：除了全局通用的组件，并且经常用到的组件使用全局注册，尽量使用局部注册

   - 全局注册：`Vue.component('my-comp', {})`
   - 局部注册
   
   组件名称的规范：一下命名方式任选其一
   
   - 使用短横线命名
   - 大驼峰命名法
   
   3) 组件的使用：把组件当做标签使用即可
   
   - 使用短横线命名
   - 大驼峰命名
   
   组件可以嵌套重复使用，因此，会形成一个组件树，组件树的根叫做根组件
   
4. 项目目录结构

   ```javascript
   - app
   	- index.html // 项目主页面
   	- src
   		- assets // 放置项目的静态文件：项目依赖、样式、图片等	
   		- services // 远程通信
   			- movieService.js
   		- components // 放置组件文件
   			- pager.js
   			- movieList.js
   			- movie.js
   			- modal.js
   		- pages // 页面级组件
   		- store // 数据仓里，vuex
   		- index.js // 项目主入口文件，仅仅负责启动Vue和Vue配置，所有的界面，交给组件app来玄滩
   		- app.js // 根组件，整个页面的内容靠该组件完成
   ```

## 3. 组件间的数据通信

### 组件的状态和属性

1. 组件状态

   1) 通常讲组件中需要自身管理的数据（组件配置中的data），叫做组件状态(component state)

   2) 组件状态只能在组件中使用，外部原则上不可以使用

   3) data在组件中的配置和在Vue实例中配置的区别：在组件中data必须是一个函数，在Vue实例中必须是一个对象

2. 组件的属性

   1) 组件可以有属性(component props)，而Vue实例中没有

   2) 声明组件属性命名时，使用短横线命名法或小驼峰命名法

   3) 传递组件属性时，使用短横线命名法或小驼峰命名法

   4) 属性会提升到Vue组件实例中

   5) **组件的属性时只读的，不允许更改，根本原因是保证单向数据流**

   6) key是内置属性，当循环渲染自定义组件时，建议使用该属性，并且提供给唯一的值，通常为id，以便Vue提高渲染效率

### 自定义事件

1. 在组件中触发事件`this.$emit("事件名", 事件参数)`
2. 当一个组件状态发生变化时，该组件重新渲染，在渲染的过程中，可能会导致其子组件的属性发生变化，而属性的变化导致组件重新渲染
3. v-model的本质是一个语法糖，实际上，是绑定value属性，同时监听input事件

### 组件生命周期

1. `boforeCreate`：组件实例刚创建好之后，此时，组件实例中还没有提升任何的成员
2. `created`：组件实例中已经提升了该有的成员，但是，此时还没有渲染页面的任何内容
3. `beforeMount`：组件即将进行渲染，但是还没有进行渲染，此时，已经编译好模板，渲染的所有条件已经满足
4. `mounted`：**【重要!!!】**组件已经完成渲染(页面可见)
5. `beforeUpdate`：组件即将更新，还没有更新，此时，得到的数据是新的，但是界面是旧的
6. `updated`：组件已经完成更新，此时数据和界面都是新的
7. `beforeDestroy`：当组件即将被销毁时
8. `destroyed`：当组件已经被销毁后

### 插槽

插槽(slot)位置放置的是：使用组件传递的内容

## 4. 企业级的解决方案

### vue-router

Vue路由，可以简单的理解为，当访问某个地址时，渲染某个组件

1. 使用路由

   1) 根据一个配置对象创建路由，的发哦路由对象 `new VueRouter({})`

   2) 创建Vue实例时，将路由对象配置到实例配置的router中

   3) 在合适的位置写上`<router-view></router-view>`，表示路由匹配到的组件渲染的位置，它实际上是vue-router做好的组件，并且进行了全局注册

2. 路由配置对象

   1) routes：路由规则配置

   2) mode：路由模式配置
   
   -  hash模式，兼容性最好，地址出现在#后面，切换地址不会导致页面刷新
   -  history模式，使用的是HTML5 History API，地址直接变化，并且页面不刷新
   
3. 导航

   1) 通常使用`<router-link></router-link>`，来切换页面，它可以自动使用配置中的模式，并且不会刷新页面

   2) router-link会自动给a元素添加样式，当前的地址如果匹配router-link中的to的地址，则会自动添加类

4. 编程式导航

   1) 当创建Vue实例时，如果配置了router，则配置的router，会出现在所有的Vue实例和组件实例中，方式是作为$router出现

   2) 跳转页面

   - `$router.push("页面地址")`：可以跳转页面（向当前页面地址栈中加入一个地址）
   - `$router.replace("页面地址")`：跳转页面（替换当前页面地址栈中当前位置的页面）
   - `$router.go(偏移位置)`：根据当前地址栈中的位置以及设置的偏移量跳转页面
   - `$router.goBack()`：相当于`$router.go(-1)`
   - `$router.goForword()`：相当于`$router.go(1)`

   3) 当配置好路由后，除了向所有实例增加`$router`属性之外，还增加了一个属性`$route`，该属性主要用于获取路径信息
   
   - `$route.params`：获取的是路由规则中匹配到的路由信息，通常称之为路由参数
   - `$route.query`：query的方式是在地址栏后面加上？号，然后依次书写数据

5. 导航守卫

   导航守卫是一些router的配置函数，不同的函数在不同的时机运行

   1) `beforeEach`：注册全局导航守卫，一旦注册了该守卫，除非在守卫中使用了next函数，否则不会改变地址

### vuex

vuex用于解决大量的、复杂的组件间**共享数据**的问题

1. 使用

   1) 通过`new Vuex.store(配置对象)`创建仓库，通常，一个Vue应用，对应一个仓库

   2) 配置对象

   - `state`：仓库的默认状态
   - `mutations`：配置的是状态有哪些变化，**mutation是状态发生变化的唯一原因**
     1. 参数
        - state
        - payload
     2. 不可以直接使用调用mutation，必须通过`仓库对象.commit`进行调用
     3. **mutation中函数，不可以出现异步等副作用操作**
        - 没有ajax
        - 没有dom操作
        - 没有外部数据处理
        - 没有当前时间
        - 没有随机数
   - `actions`：配置副作用操作
     1. 参数
        - 上下文对象(context)，几乎等同于仓库对象
        - payload
     2. 通过`仓库对象.dispatch`进行调用
   
2. 当配置了vuex之后，所有vue实例都会出现一个属性：`$store`

3. 如果组件需要使用仓库中的数据，需要使用计算属性封装，可以使用mapState简化封装

## 5. 综合性的项目实践

## 6. 复盘总结与强化提升









